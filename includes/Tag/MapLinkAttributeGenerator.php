<?php

namespace Kartographer\Tag;

use Kartographer\Special\SpecialMap;
use MediaWiki\Json\FormatJson;

/**
 * @license MIT
 */
class MapLinkAttributeGenerator {

	// Warning, all constants must be the same as in
	// https://github.com/wikimedia/makizushi/blob/master/lib/color.js
	private const LIGHT_COLOR = '#fff';
	// Semi-black text color @color-base according to Wikimedia Codex
	private const DARK_COLOR = '#202122';

	// Arrived at by playing with an APCA contrast calculator and finding the
	// luminance where contrast is equal for both dark (Base10) and light symbol fills.
	private const LUMINANCE_THRESHOLD = 0.386;

	public function __construct(
		private readonly MapTagArgumentValidator $args,
	) {
	}

	/**
	 * Prepare MapLink array of attributes to be passed to the Node element
	 */
	public function prepareAttrs(): array {
		$attrs = [
			'class' => [ 'mw-kartographer-maplink' ],
			// Attributes starting with "data-mw" are banned from user content in Sanitizer;
			// we add such an attribute here (by default empty) so that its presence can be
			// checked later to guarantee that they were generated by Kartographer
			'data-mw-kartographer' => 'maplink',
			'data-style' => $this->args->mapStyle,
			'href' => SpecialMap::link(
					$this->args->lat,
					$this->args->lon,
					$this->args->zoom,
					$this->args->getLanguageCodeWithDefaultFallback()
				)
		];

		if ( $this->args->zoom !== null ) {
			$attrs['data-zoom'] = (string)$this->args->zoom;
		}

		if ( $this->args->hasCoordinates() ) {
			$attrs['data-lat'] = (string)$this->args->lat;
			$attrs['data-lon'] = (string)$this->args->lon;
		}

		if ( $this->args->specifiedLangCode !== null ) {
			$attrs['data-lang'] = $this->args->specifiedLangCode;
		}

		if ( $this->args->firstMarkerColor ) {
			$attrs['class'][] = 'mw-kartographer-autostyled';
			$color = $this->contrastingFill( $this->args->firstMarkerColor );
			// Must contain both background and foreground for WCAG compliance
			$attrs['style'] = "background-color: {$this->args->firstMarkerColor}; color: $color;";
		}

		if ( $this->args->cssClass !== '' ) {
			$attrs['class'][] = $this->args->cssClass;
		}

		if ( !$this->args->hasCoordinates() && $this->args->getTextWithFallback() === null ) {
			$attrs['class'][] = 'error';
		}

		if ( $this->args->showGroups ) {
			$attrs['data-overlays'] = FormatJson::encode( $this->args->showGroups, false,
				FormatJson::ALL_OK );
		}

		return $attrs;
	}

	/**
	 * Transform an sRGB component to the vector expected by the relative luminance formula.
	 */
	private function sRgbToLinear( string $value ): float {
		$f = hexdec( $value ) / 255.0;
		return $f <= 0.03928 ?
			$f / 12.92 :
			pow( ( $f + 0.055 ) / 1.055, 2.4 );
	}

	private function contrastingFill( string $background ): string {
		if ( strlen( $background ) === 4 ) {
			$r = $background[1] . $background[1];
			$g = $background[2] . $background[2];
			$b = $background[3] . $background[3];
		} else {
			$r = substr( $background, 1, 2 );
			$g = substr( $background, 3, 2 );
			$b = substr( $background, 5, 2 );
		}

		$r = $this->sRgbToLinear( $r );
		$g = $this->sRgbToLinear( $g );
		$b = $this->sRgbToLinear( $b );

		// Factors from https://www.w3.org/TR/WCAG20/#relativeluminancedef
		$luminance = 0.2126 * $r + 0.7152 * $g + 0.0722 * $b;

		return $luminance > self::LUMINANCE_THRESHOLD ? self::DARK_COLOR : self::LIGHT_COLOR;
	}

}
